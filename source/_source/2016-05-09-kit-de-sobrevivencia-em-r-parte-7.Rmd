---
layout: post
title: "Kit de sobrevivência em R - Parte 7: Avançando e Aprofundando"
date: 2016-05-09 20:04:00 -0300
comments: true
categories: [r, básico, introdução r]
published: true
---
  
```{r, echo = FALSE}
desemprego.uf <- read.table("https://www.dropbox.com/s/beqwi0zxltcchb0/desemprego_uf_ponto_virgula.txt?raw=1",
                            dec = ",", sep = ';')
```

Chegamos ao fim do [kit de sobrevivência em R]({{root_url}}/blog/categories/introducao-r). Nesse último post da série vamos retomar alguns pontos que merecem ser complementados e revisados, além de apresentar um pouco mais de transformações e operações usando apenas funções básicas do R.

<!-- More -->

Se você seguiu a sequência e chegou até aqui, parabéns! Você provavelmente conhece o básico de R e o suficiente para começar a aprofundar em aspectos mais interessantes sobre operações com massas de dados.

## Breve revisão sobre pacotes 

Mostramos que pacotes são conjuntos de funções específicas agrupadas para objetivos temáticos: carregar dados, gráficos, machine learning. É muito simples carregar e utilizar pacotes. Vamos relembrar os principais comandos envolvidos:

```{r, eval = FALSE}
??dplyr #conhecendo um pacote que não foi carregado ainda
install.packages('dplyr') #instalando um pacote
library(dplyr) #carregando um pacote para uso
?dplyr::filter #conhecendo alguma função do pacote
```

## Carregando dados

Lembre-se que antes de carregar um arquivo de dados você precisa informar onde o R deve ler o arquivo. Para isso usamos o comando `setwd()`.

A função mais básica para leitura de dados estruturados (csv, tabular, tamanho fixo, com separadores, etc.) é o famoso `read.table()`. Lembra dos principais parâmetros? Nome do arquivo, separador, se tem cabeçalho ou não, e, no caso de campos com tamanho fixo, o tamanho de cada campo.

Se quiser exercitar com diversos arquivos de dados diferentes, tente o [Portal Brasileiro de Dados Abertos](http://dados.gov.br/) ou [esse repositório de dados públicos](https://github.com/caesar0301/awesome-public-datasets) (em inglês).

Comentamos de algumas funções básicas para começar a explorar seus dados carregados. Você lembra?

```{r}
?head()
?tail()
?str()
```

> Dica: se estiver usando o RStudio, tente visualizar seu data.frame com a função `View()` (com V maiúsculo). Ela cria uma planilha para ver melhor os dados!

## Tipos e estrutura de dados

Conhecer os tipos e estruturas de dados em R será fundamental daqui pra frente. Achamos importante revisar e apresentar alguns dos principais.

### Tipos básicos

| Tipo | Descrição |
|------|:-------------|
| **logical** | Valor lógico, `TRUE` ou `FALSE`. Usado com os operadores lógicos `&, |, ==, !=, >, <, >=, <=` |
| **integer** | Valores de números inteiros |
| **numeric** | Valores de números decimais. Também representam números inteiros |
| **character** | Valores textuais, também conhecidos como string |

<br/>  

### Conversões

Existem algumas operações de conversões entre os tipos. São bastante usadas em transformações de campos. Por exemplo:

```{r}
as.numeric("20")
as.character(20)
as.integer(3.14)
```
  
### Estruturas básicas

Dominar as estruturas de dados do R será fundamental no desenvolvimento das suas análises. Inicialmente, a ideia de estrutura de dados pode parecer um pouco abstrata, mas conhecê-las e saber suas características será útil para você perceber quais são as possibilidades.

A tabela abaixo apresenta um resumo das estruturas básicas. Ela está baseada na explicação que está no livro do [_Advanced R_](http://adv-r.had.co.nz/Data-structures.html) do Hadley Wickham (leitura recomendada pra quem deseja aprofundar seus conhecimento em R).

Do que se trata o campo `Dimensões` na tabela? Na prática, isso afetará como você usará partes desse objeto. Por exemplo, um objeto com duas dimensões tem linhas e colunas. Assim, você usará `[ , ]` (com vírgula separando linha e coluna, respectivamente) para acessar a dimensão que você deseja selecionar. Já um objeto unidimensional terá seus elementos acessados usando apenas `[ ]`. A lista, por sua vez, tem seus elemtnos acessados com `[[ ]]`.

E o campo `Homogêneo` da tabela? Trata-se de mais uma características das estruturas de dados. Diz respeito à variedade de tipos básicos que um objeto pode conter. Por exemplo, vetores só aceitam um tipo de dado. Assim, se você atribuir dois tipos diferentes, ele forçará para um único tipo. Listas e data frames aceitam diferentes tipos de dados.


| Tipo | Descrição | Dimensões | Homogêneo |
|---|:---|---|---|---|
| **vector** | Coleção de elementos simples. Todos os elementos precisam ser do mesmo tipo básico de dado | 1 | Sim |
| **array** | Coleção que se parece com o vector, mas é possível adicionar atributos às posicões e dimensões | n | Sim |
| **matrix** | Tipo especial de array com mais de uma dimensão | 2 | Sim |
| **list** | Objeto complexo com elementos que podem ser de diferentes tipos | 1 | Não |
| **data.frame** | Tipo especial de lista onde cada campo é um vetor de apenas um tipo e todos os campos tem o mesmo número de registros. É o tipo mais utilizado se trabalhar com dados | 2 | Não |
| **factor** | Tipo especial de vector que só contém valores pré definidos (levels) e categóricos (characters). Não é possível adicionar novas categorias sem criação de novos levels | 1 |  Não |

<br/>  

### Observações sobre listas 

Lista pode causar um pouco de confusão no começo. Daremos alguns exemplos para explicar melhor.

Iremos criar listas com duas bases de dados que já vem fornecidas como exemplo no próprio R.

Primeiramente, iremos carregar as duas bases de dados:

```{r}
data("mtcars")
data("iris")
class(mtcars)
class(iris)
```

Veja que temos dois data frames. Agora, vamos criar um objeto único que irá receber essas duas bases. Além disso, a fim de mostrar a heterogeneidade, iremos incluir um objeto que será um vetor. Veja abaixo:

```{r}
x <- 1:10
lista.teste <- list(mtcars, iris, x)
```

Faça um teste e digite `lista.teste` no console para ver o resultado. 

E como eu faço pra acessar partes específicas? Como dissemos a lista tem uma pequena diferença, será necessário usar o `[[ ]]`. Lembre-se que, como a lista é um objeto de dimensão 1, só precisaremos passar o índice que temos interesse. O vetor `x` é o terceiro elemento. Logo, para acessá-lo podemos fazer o seguinte:

```{r}
lista.teste[[3]]
```

Para terminar essa breve explicação sobre listas, vamos mostrar que cada objeto de uma lista pode ter um nome:
```{r}
lista.teste <- list(base1 = mtcars, base2 = iris, vetor1 = x)
```

Dessa forma, você *também* poderá acessar usando o nome com o auxílio do `$`:
```{r}
lista.teste$vetor1
```

### Observações sobre vectors

Vectors possuem algumas propriedades muito úteis como `length()`, `typeof()` e `unique()`. Você também poderá usar o `length()` para saber o tamanho de uma lista. 

### Observações sobre data.frames

As funções `nrow()` e `ncol()` podem ser usadas para saber, respectivamente, o número de linhas e colunas de um data.frame (ou de uma matriz).

Data.frames também podem ter o nome das colunas alterados. Veja o exemplo a seguir:

```{r}
head(iris)
names(iris)
names(iris) <- c("campo1", "campo2", "campo3", "campo4", "campo5")
head(iris)
```

## Valores Faltantes (Missing)

O R atribui `NA` para valores faltantes. Ou seja, se por acaso uma determinada posição de um vetor ou de uma coluna de um data.frame não possui valor algum, o R mostrará `NA`. Em algumas bases de dados, quem gera o dado atribui valores genéricos como 999. Nesse caso, você provavelmente terá que substituir o 999 por `NA`. E como eu lido com `NA` no R? Vamos explicar as funções básicas para começar.

Em primeiro lugar, vamos criar um simples data.frame para exemplificar:

```{r}
data.ex <- data.frame(col1 = letters[1:6], col2 = c(10, 20, 30, NA, 50, NA))
data.ex
summary(data.ex)
```

Usamos o `letters` que é uma constante embutida no R que retorna as 26 letras do alfabeto. No caso, usamos só as seis primeiras. Na seguda columa, colocamos alguns NA's. A função `summary` mostra que existem dois NA's na `col2`. Nesse exemplo, fica fácil para encontrar onde estão os NA's e fazer alguma modificação caso deseje, mas considere um caso em que seu data.frame é grande. Você não iria conseguir identificar no olho. Assim, é necessário usar algumas funções. Vamos começar como o `is.na()`:

```{r}
is.na(data.ex$col2)
which(is.na(data.ex$col2))
```

O `is.na()` realiza um teste para saber se cada elemento da variável `col2` é um missing. Além disso, se usarmos o `is.na()` dentro da função `which()` saberemos quais os índices que possuem o `NA`. Um detalhe importante sobre funções que retornam `TRUE` ou `FALSE` como o `is.na()` é que você pode usar a `!` para fazer o teste ao contrário. Isto é, se quisermos saber quais não são `NA`, faremos o seguinte:

```{r}
!is.na(data.ex$col2)
```

Notou que a função retornou o contrário de `is.na(data.ex$col2)`? 

Agora iremos introduzir a função `complete.cases()`. Essa função retorna `TRUE` para as linhas em que todas as colunas possuem valores válidos e `FALSE` para as linhas em que em alguma coluna existe um `NA`.

```{r}
complete.cases(data.ex)
!complete.cases(data.ex)
```

Podemos usar o retorno dessa função para selecionar linhas do nosso data.frame:

```{r}
data.ex[!complete.cases(data.ex),]
data.ex[complete.cases(data.ex),]
```

Você poderiar usar a função `na.omit()` para obter o mesmo resultado da seleção de linhas com o `complete.cases()`:

```{r}
na.omit(data.ex)
```

Por fim, iremos imputar a média da `col2` nas linhas em que há `NA`. Para isso, usaremos o `ifelse()` que tratamos na [parte 6]({{root_url}}/blog/2016/05/01/kit-de-sobrevivencia-em-r-parte-6/) e os `is.na()`, além da função `mean()`.

```{r}
# Calcular a média da col2
media.col2 <- mean(data.ex$col2, na.rm = TRUE)
media.col2
data.ex$col2[is.na(data.ex$col2)] <- media.col2
data.ex
```

Note que na função `mean()` usamos o argumento `na.rm`. Ele significa "remover NA", o que é necessário nesse cálculo, pois se os NA's não forem retirados, a média será `NA` também.

## Exemplo final: Titanic

Vamos dar um exemplo final de algumas transformações e manipulações de dados na tentativa de resumir todos os aspectos tratados no kit de sobrevivência em R.

Escolhemos a base de dados dos passageiros do Titanic! É uma base muito utilizada como tutorial de machine learning onde o objetivo é criar um modelo para prever os sobreviventes do acidente. Se você pretende aprender machine learning, certamente vai esbarrar (ou já esbarrou) com essa base de dados. Inclusive há uma série de [tutoriais de machine learning com essa base no Kaggle](https://www.kaggle.com/c/titanic).

Nosso objetivo não é criar nenhum modelo nem ensinar a fazer isso, vamos apenas explorar a base, manipular, transformar e criar algumas variáveis. Teremos muitos posts em breve sobre modelos preditivos e machine learning!

Primeiro criamos um novo script, lembre-se sempre de salvar o seu trabalho para não perder nada. Em seguida vamos limpar o ambiente de memória para começar.

```{r}
rm(list = ls())
```

Vamos instalar e carregar o pacote R que disponibiliza os dados.

```{r, message = FALSE, warning = FALSE}
install.packages('titanic')
library(titanic)
```

O data frame que iremos usar já estará carregado na memória e se chama `titanic_train`. Trata-se da base de treinamento usada para treinar modelos. Vamos dar uma olhada. As bases de treinamento já vem com a resposta na variável que você quer descobrir na base de teste. Nesse caso os modelos que usam essa base são treinados para descobrir a variável `Survived`.

```{r}
str(titanic_train)
head(titanic_train)
```

Repare que cada linha representa um passageiro e cada campo representa uma característica desse passageiro. As variáveis (campos) estão em inglês e talvez não sejam tão óbvias. Segue explicação de cada uma:

Nome do campo | Descrição do campo
--------------|:-------------
Survived      | Passageiro sobrevivente (1) ou morto (0)
Pclass        | Classe do passageiro
Name          | Nome do passageiro
Sex           | Genero do passageiro (male ou female)
Age           | Idade do passageiro
SibSp         | Número de irmãos ou conjuges a bordo
Parch         | Número de pais ou filhos a bordo
Ticket        | Número do tíquete
Fare          | Preço do tíquete
Cabin         | Cabine
Embarked      | Portão de embarque

Vamos traduzir os nomes dos campos para facilitar o entendimento. Para isso usaremos a função `names()`

```{r}
names(titanic_train)
names(titanic_train) <- c('id_passageiro', 'sobrevivente', 
			'classe', 'nome', 'sexo', 'idade',
			'irmaos_conjuge', 'pais_filhos', 'numero_ticket', 'valor_ticket', 'cabine', 'porta_embarque')
```

Como o objetivo dessa base de dados é treinar um modelo para descobrir se o passageiro vai sobreviver ou não, vamos manipular e criar variáveis para tentar ajudar a atingir esse objetivo.

Vamos começar com a variável `idade`. Há um comportamento interessante nessa variável:

```{r}
unique(titanic_train$idade)
```

Repare que dentre os valores únicos temos um `NA`. Isso significa que existem linhas nessa coluna que estão vazias. É muito comum lidar com conjuntos de dados que tenham ocorrências de `NA` em alguns campos. É importante saber o que fazer em casos de `NA`, e nem sempre a solução será a mesma, vai variar de acordo com suas necessidades.

Nesse nosso caso específico, vamos interpretar `NA` como se o passageiro tivesse a idade desconhecida. Dependendo do algoritmo de machine learning que será aplicado a esses dados, a presença de `NA` não é bem vinda.

A título de exemplificação, vamos adicionar a média geral das idades quando não soubermos a idade do passageiro. (Veja, essa nem sempre é uma boa estratégia para imputação de dados. Vamos usá-la agora apenas por ser bem simples).

```{r}
media <- mean(titanic_train$idade, na.rm = TRUE)
media
titanic_train$idade <- ifelse(is.na(titanic_train$idade), round(media), titanic_train$idade)
```

Calculamos a média desconsiderando ocorrências de `NA`, em seguida atribuímos a média (arredondada) às ocorrências de `NA`. 

Agora todos os passageiros tem idade. Alguns a idade correta, outros uma idade atribuída. Vamos criar agora uma classificação de `jovem`, `adulto` ou `idoso` para essa variável. Até 20 anos chamaremos de `jovem`, de 21 a 54 chamaremos de `adulto`, e acima de 55 chamaremos de `idoso`. Vamos chamar essa variável de `faixa_etaria`.

```{r}
titanic_train$faixa_etaria <- ifelse(titanic_train$idade <= 20, 'jovem', ifelse(titanic_train$idade > 21 & titanic_train$idade < 55, 'adulto', 'idoso'))
head(titanic_train[,c('idade', 'faixa_etaria')], 15)
```



## Referências

* []()